우리나라에서 개발자 공고를 보면 꼭 이런 말이 따라붙거든요:

- Java에 익숙한 분
    
- Spring Framework 경험자

자바는 배워봤지만, 백엔드 쪽에 제대로 써본 적은 없던 저로선 항상 이게 마음에 걸렸죠.  
“대체 자바랑 스프링이 뭐길래 이렇게들 찾는 거지?”  
그때부터 시작된 자바에 대한 의문, 그리고 실무를 마주하며 알게 된 현실. 지금부터 그 얘기를 해보려 해요.

### 1. 대한민국에 자바 + 스프링이 자리 잡은 이유

회사에서 백엔드 개발한다고 하면, 열에 아홉은 자바 + 스프링이에요.  
대체 왜 이렇게 굳건한 걸까?

크게 보면 세 가지쯤 되는 것 같아요:

- **기업 친화적인 생태계**  
    오라클이건, 이제는 오픈JDK건 간에 “신뢰감 있는 언어”라는 이미지가 있어요.  
    공공기관, 금융권은 특히 이걸 많이 봐요. 도입하기 무난하고, 레퍼런
    도 많고요.
    
- **스프링 프레임워크의 대세화**  
    한때는 EJB, 스트럿츠, 하이버네이트, 아이바티스… 다양했는데,  
    스프링이 그 복잡한 것들 다 감싸 안고 “일단 스프링 쓰자”가 돼버렸죠.
    
- **국내 개발교육과 채용 시장**  
    대학교든 부트캠프든 자바 기반으로 배우는 경우가 많아서,  
    자연스럽게 실무도 자바, 프로젝트도 자바, 이직도 자바.
    
* **꾸준하고 안정적인 언어**  
	1995년에 나왔는데 아직도 건재한 걸 보면, 이미 말 다 했죠.  
	기업 입장에선 리스크가 적고, 오래 굴릴 수 있는 언어가 필요하니까요.


요약하면: **쌓여 있는 게 많고, 사람도 많고, 문서도 많고, 기업이 좋아함.**

---

### 2. 자바의 한계점

우선 자바는 좋은 언어입니다.
그리고 매 버전 출시될 때 마다 발전하고 뒤처지지 않기 위해 현대 언어의 흐름을 쫓아가려고 하구요.

이렇게 말해놓고도... 사실 자바는 불편해요.  아니 정확히 말하자면 편한 언어는 아니에요.
이건 써본 사람만 알아요.

- **장황한 문법**  
    리스트 하나 필터링하는 데 람다 쓰려고 하면 막 `stream().filter().collect()`  
    가독성은 점점 ...
    
- **보일러플레이트**  
    DTO 하나 만들자고 `getter/setter/toString/equals/hashCode` 한 세트를 매번 생성.  
    Lombok 없으면 진짜 지옥.
    
- **Null 처리의 허술함**  
    NPE는 자바의 전통이죠.  
    “이거 null일 수도 있잖아?” → `if (obj != null)`의 반복.  
    결국 Optional, orElse, null-safe utility… 흠.

“그냥 더 간단하게 쓸 수는 없을까?” 하는 마음이 생기더라고요.

### 3. 코틀린의 등장

사람들은 늘 뭔가 더 편한걸 찾죠.

특히 안드로이드 개발자들 사이에서 그런 불만이 컸어요.  
앱 만들 때마다 터지는 NPE, 지겹도록 반복되는 `getter/setter`,  
그 와중에 XML과의 조합까지… 피곤한 일이 한둘이 아니었거든요.

그러던 어느 날, JetBrains에서 만든 새로운 언어가 등장했어요.  
이름은 **Kotlin**.

당시 JetBrains 의 상황과 개발동기를 아래와 같이 말했어요.
- JetBrains은 자바를 포함하여 JVM 베이스인 여러 언어의 IDE를 만드는 회사이며, 대부분의 소스 코드가 자바로 쓰여있다.
- 그러나 우리는 더 많은 생산성(more productivity)을 원했으며, 그렇다고 이미 쓰여진 자바를 포기할 수도 없었다.
- 그래서 우리는 자바와의 상호 호환성을 전제로 하는 언어인 코틀린을 개발하기 시작했다.

처음엔 그냥 "자바랑 호환 잘 되는 언어 하나 나왔대" 정도였는데,  
막상 써보면 느낌이 달랐죠.

- 기본적으로 NPE를 방어해줌
    
- 확장 함수, 스마트 캐스팅, 데이터 클래스 등 편의 기능이 많음
    
- 자바보다 훨씬 간결함
    
- 그런데도 자바와 100% 호환됨
    
- 스프링도 잘 돌아감

이쯤 되면 당연히 관심이 쏠릴 수밖에 없고,  
구글이 안드로이드 공식 언어로 코틀린을 채택하면서  
"자바 대체 가능성"이라는 말이 진지하게 오가기 시작했죠.

서버 개발자들 입장에서도 상황은 비슷했어요.

> “내가 자바로 만들던 거, 이걸로도 똑같이 되는데 더 편하네?”

코틀린은 그렇게,  
**자바의 단점은 덜고 장점은 그대로 가져온**, 꽤 현실적인 대안으로 떠올랐습니다.

### 4. 그래서 코틀린은 뭐가 더 나은데?

 이사코바는 코틀린의 디자인 철학에 대해 아래와 같이 설명했습니다.

- 코틀린은 자바의 고질적인 문제였던 **널(null) 안정성을 해결**하고자 했다
- 개발자들은 평생동안 코드를 쓰는 데보다 읽는 데에 더 많은 시간을 할애한다. 그러므로 코틀린은 **가독성에 초점**을 뒀다.

정리해볼게요.  
자바 → 코틀린으로 옮기면서 제가 바로 느꼈던 변화들입니다:

- **줄어든 코드량**  
    진짜 장난 아니게 줄어요.  
    DTO 하나 만들면 끝나는 걸, 자바에선 몇 배의 코드가 필요하니까요.
    
- **Null 안정성**  
    `?.`, `?:`, `!!` 같은 문법으로 null 체크가 일상처럼 자연스러워요.  
    덕분에 NPE에 대한 불안이 거의 사라짐.
    
- **읽기 쉬운 문법**  
    `when`, `data class`, `val/var`, `extension`, `top-level function` …  
    익숙해지면 자바보다 훨씬 눈이 편합니다.
    
- **함수형 스타일과 컬렉션 처리**  
    `filter`, `map`, `flatMap` 같은 건 자바보다 훨씬 쓰기 간단하고 가독성도 좋아요.
    

물론 단점도 있어요.  
빌드 속도나 디버깅 편의성 같은 건 자바 쪽이 아직 앞서는 부분도 있고,  
팀 전체가 코틀린에 익숙하지 않다면 도입 자체가 장벽일 수도 있어요.

하지만 개인적으는, **“코틀린 써보고 다시 자바로 못 돌아간다”** 는 말, 좀 이해가 가더라고요.


### 마무리를 지으며

코틀린을 처음 접했을 때 느꼈던 건,  
단순히 “문법이 예쁘다” 정도가 아니라,  
**언어 전체가 개발자의 실수와 반복을 줄이도록 설계돼 있다**는 점이었어요.

그래서 다음 글에서는  
**코틀린이 어떤 철학으로 만들어졌는지, 내부적으로 어떻게 동작하는지**  
조금 더 깊이 들어가 보려고 합니다.

코틀린을 단순히 "자바보다 간편한 언어"로만 보는 시선에서 벗어나,  
**왜 그렇게 설계되었는지**, 그리고 **그게 실무에 어떤 영향을 주는지** 함께 이야기해볼게요.